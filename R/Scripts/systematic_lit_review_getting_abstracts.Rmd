---
title: "Systematic literature review - Getting abstracts"
author:
- name: Vincent Bagilet
  url: https://www.sipa.columbia.edu/experience-sipa/sipa-profiles/vincent-bagilet
  affiliation: Columbia University
  affiliation_url: https://www.columbia.edu/
- name: Léo Zabrocki
  url: https://www.parisschoolofeconomics.eu/en/
  affiliation: Paris School of Economics
  affiliation_url: https://www.parisschoolofeconomics.eu/en/
date: "`r Sys.Date()`"
output:
  distill::distill_article: default
  html_notebook: default
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE, results='hide', warning=FALSE}
library(knitr)
opts_chunk$set(fig.path = "images/",
               cache.path = "cache/",
               cache = FALSE,
               echo = FALSE, #set to false to hide code
               message = FALSE,
               warning = FALSE,
               out.width = "85%",
               dpi = 200,
               fig.align = "center")  
```  

```{r include=FALSE}
library(tidyverse)
library(fulltext)
library(tidytext)
library(wordcloud)
library(retrodesign)
library(mediocrethemes)
library(lubridate)
library(DT)

set_mediocre_all()
set.seed(1)
```

# Purpose of the document

In the present document, we retrieve abstracts and full texts for our systematic review of the literature on short term health effects of air pollution. 

# Selecting articles and retrieving metadata

We use the [`fulltext`](https://books.ropensci.org/fulltext/) package to get the abstract and full text of each article corresponding to our search query. This set of articles might be too restrictive and we may want to broaden our scope later. 

To begin with, we focus on articles published on Scopus and Pubmed. To access Scopus API, one needs to register to get an API key (stored in the .Renviron) for Elsevier and a Crossref TDM API key. Note that downloading of full texts may not work if one is not connected directly to their institution internet network. Pubmed articles are accessed via Entrez. An API key enables to increase the number of requests per seconds from 3 to 10. More information on authentication is available on [the `fulltext` manual](https://books.ropensci.org/fulltext/authentication.html).

## Set of articles to consider

First of all, we need to clearly define the set of articles we want to consider in this analysis. Our baseline search query is: 

'"air pollution" AND ("emergency" OR "mortality") AND ("particulate matter" OR ozone OR "nitrogen dioxyde" OR "sulfur dioxide")'. 

This returns about 57000 articles (without accounting for duplicates in between journals). This number being rather large, we want to narrow it down. To focus on the epidemiological literature, we add the query term `poisson`. To get causal analyses, we add the term `causal`. 

```{r eval = FALSE}
query <- 'TITLE(("air pollution" OR "air quality" OR "particulate matter" OR ozone OR "nitrogen dioxide" OR "sulfur dioxide" OR "PM10" OR "PM2.5" OR "carbon dioxide" OR "carbon monoxide") AND ("emergency" OR "mortality" OR "stroke" OR "cerebrovascular" OR "cardiovascular" OR "death" OR "hospitalization") AND NOT ("long term" OR "long-term")) AND "short term"'# AND (poisson OR causal)'

opts_entrez <- list(use_history = TRUE)

#Run a search
search <- ft_search(query, from = "scopus", limit = 2000)
search_entrez <- ft_search(query, from = "entrez", limit = 200, entrezopts = opts_entrez)
```

The final query is thus:

'TITLE(("air pollution"  OR "air quality" OR "particulate matter" OR ozone OR "nitrogen dioxide" OR "sulfur dioxide") AND ("emergency" OR "mortality") AND NOT ("long term" or "long-term")) AND ("particulate matter" OR ozone OR "nitrogen dioxide" OR "sulfur dioxide")'

Then, we retrieve the related metadata. The metadata from different sources having different shapes, we only select a few relevant columns to build an overall metadata set.

```{r eval = FALSE}
metadata_scopus <- search$scopus$data %>% 
  as_tibble() %>% 
  rename_all(function(x) str_remove_all(names(.), "prism:|dc:")) %>% 
  rename_all(function(x) str_replace_all(names(.), "-", "_")) %>% 
  select(doi, title, creator, publicationName, pubmed_id, coverDate) %>% 
  rename(
    authors = creator,
    journal = publicationName
  ) %>% 
  mutate(
    pubmed_id = ifelse(!str_detect(pubmed_id, "[0-9]{7}"), NA, pubmed_id),
    pub_date = ymd(coverDate)
  ) %>% 
  select(-coverDate)

saveRDS(metadata_scopus, "../Outputs/metadata_scopus.RDS")

metadata_entrez <- search_entrez$entrez$data %>% #search_entrez$entrez$data 
  as_tibble() %>% 
  # rename(id = uid) %>% 
  select(doi, title, authors, fulljournalname, pmid, pubdate) %>% 
  rename(
    journal = fulljournalname,
    pubmed_id = pmid
  ) %>% 
  mutate(
    pubmed_id = ifelse(!str_detect(pubmed_id, "[0-9]{7}"), NA, pubmed_id),
    pub_date = ymd(pubdate)
  ) %>% 
  select(-pubdate)

saveRDS(metadata_entrez, "../Outputs/metadata_entrez.RDS")

metadata_lit_review <- metadata_scopus %>% 
  rbind(metadata_entrez) %>% 
  filter(!is.na(doi)) %>% 
  mutate(pb_doi = str_detect(doi, "[<>;]")) %>% #some dois are not valid
  filter(pb_doi == FALSE) %>% 
  select(-pb_doi)

# saveRDS(metadata_lit_review, "../Outputs/metadata_lit_review.RDS")
```

# Analysis of the power in the literature

## Retreiving abstracts

First, we focus on the abstracts and download them. 

There is no `fulltext` function to access abstracts from Entrez. Therefore, using the DOI, we get the abstracts from Semantic Scholar. We also access Scopus abstracts from Semantic Scholar since, due to my IP address being located outside of Columbia, I cannot access the texts and abstracts from Scopus.

In Semantic Scholar, there is a rate limit of 100 articles per 5 min or 20 articles per minute. We therefore need to pause the system to be able to download everything. In addition, some DOIs are not valid so we filtered them out in a previous step (`pb_doi`).^[In case any problem remains, we use tryCatch to record the DOIs corresponding to errors in order to be able to handle them later.]

```{r eval = FALSE}
get_abstracts <- function(doi) {
  vect_doi <- unique(doi)
  number_periods <- (length(vect_doi) - 1) %/% 20
  abs <- NULL

  message(str_c("Total downloading time: ", number_periods, "min"))
  
  for (i in 0:number_periods) {
    
    doi_period <- vect_doi[(20*i+1):(20*(i+1))]
    doi_period <- doi_period[!is.na(doi_period)]
    
    skip_to_next <- FALSE #to handle issues, using tryCatch
    
    possible_error <- tryCatch(
      abs_period <- doi_period %>%
        ft_abstract(from = "semanticscholar") %>%
        .$semanticscholar %>%
        as_tibble() %>%
        unnest(cols = everything()) %>%
        pivot_longer(everything(), names_to = "doi", values_to = "abstract") %>%
        filter(doi != abstract),
      error = function(e) e
    )
    
    if (inherits(possible_error, "error")) {
      warning(str_c("The abstracts for the following articles could not be downloaded: ", str_c(doi_period, collapse = ",")))
      next
    } else {
       abs <- abs %>%
        rbind(abs_period)
    }
    
    if (i < number_periods & number_periods != 0) {
      message(str_c("Remaining time: ", (number_periods - i), "min"))
      Sys.sleep(63)
    }
  } 
  
  return(abs)
}

abstracts <- metadata_lit_review %>%
  distinct(title, .keep_all = TRUE) %>% 
  .$doi %>% 
  get_abstracts()  %>% 
  left_join(metadata_lit_review, by = "doi") 

# saveRDS(abstracts, "../Outputs/abstracts.RDS")

```

## Retreiving effects and confidence interavals

```{r}
abstracts <- readRDS("../Outputs/abstracts.RDS")
```

Then we want to extract the effects, odds ratio and associated confidence intervals in the abstracts. Part of the literature, display directly effects and confidence intervals in their abstracts.^[We analyse the characteristics of articles doing soin another document.] We thus consider these abstracts (about 684 abstracts) and identify effects and CIs as follows:

- CI: any couple of numbers following by less than 4 characters a string describing a confidence interval ("95%", "CI", "confidence interval"). We also consider confidence intervals of the shape "(-8.7, 54.7)": it needs to have a shape "(number separator number)" and needs to be preceded by a number less than 5 characters away.
- Effect: the first number preceding by less than 30 characters a similar string describing a confidence interval (we do not consider "95%").


```{r}
string_confint <- "((?<!(\\.|\\d))95\\s?%|(?<!(\\.|\\d))95\\s(per(\\s?)cent)|\\bCI(s?)\\b|\\bPI(s?)\\b|\\b(i|I)nterval|\\b(c|C)onfidence\\s(i|I)nterval|\\b(c|C)redible\\s(i|I)nterval|\\b(p|P)osterior\\s(i|I)nterval)"
# string_confint_detect <- "(?<!(\\.|\\d))(95)?\\s?%?(per(\\s?)cent)?\\s?(\\bCI(s?)|(\\b(c|C)onfidence\\s)?(i|I)nterval(s?))(\\s?(\\(|\\[)?CIs?(\\)|\\])?)?"
num_confint <- "(-\\s?|−\\s?)?[\\d\\.]{1,7}[–\\s:;,%\\-to\\‐-]{1,5}(-\\s?|−\\s?)?[\\d\\.]{1,7}"
num_effect <- "(-\\s?|−\\s?)?[\\d\\.]{1,7}"

effects_CI <- abstracts %>% 
  mutate(
    abstract = str_replace_all(abstract, "·", "."),
    abstract = str_replace_all(abstract, "C.I.", "CI")
  ) %>% 
  select(doi, abstract) %>% 
  unnest_tokens(sentence, abstract, token = "sentences", to_lower = FALSE, drop = FALSE) %>% 
  mutate(
    contains_CI = str_detect(sentence, string_confint),
    sentence = str_replace_all(sentence, "(?<=(?<!\\.)(?<!\\d)\\d{1,4}),(?=(\\d{3}(?!\\.)))", "")
  ) %>%
  filter(contains_CI) %>%
  # mutate(
  #   effect_CI = str_extract_all(sentence, str_c(
  #   num_effect, "[^\\d\\.]{0,17}([^\\.\\d]",
  #   string_confint, ").{0,35}((?<=", string_confint, "[^\\d]{0,4})",
  #   num_confint, "[^\\d\\.]{0,3}[\\)\\];,])|", num_effect, "[^\\d\\.]{0,5}(\\(|\\[)", num_confint, "%?[\\)\\];](?<![^\\.\\d]95)"))
  # ) %>%
  # unnest(effect_CI, keep_empty = TRUE) %>% 
  mutate(
    CI = str_extract_all(sentence, str_c(
      "((?<=", string_confint, "[^\\d]{0,4})", num_confint, ")|",
      "(?<=", num_effect, "[^\\d\\.]{0,5})(?<=(\\(|\\[))", num_confint, "(?=%?[\\)\\];])")
    ),   
    effect = str_extract_all(sentence, str_c(
      num_effect, "(?=[^\\d\\.]{0,30}([^\\.\\d]", string_confint, "))(?<!\\b95)|",
      num_effect, "(?=[^\\d\\.]{0,5}(\\(|\\[)", num_confint, "(?=%?[\\)\\];]))(?<![^\\.\\d]95)")
    )
  ) 
  # select(-effect_CI)
```

These lines of code return a set of confidence intervals and effect for each sentence containing the phrase ("CI", "confidence interval", etc). We could improve this code by linking directly each effect to its confidence interval. For now, if we do not detect the same number of effects and confidence interval in a sentence, we drop the sentence, even though there are 5 pairs of effect-CI and only one of them is badly detected.

Note that some problems might remain with our estimates and CIs detected. Yet, a vast majority of estimates are correctly detected. Here are examples of the confidence intervals and effects detected using our current method:

```{r}
random_sentences <- sample(1:length(effects_CI$sentence), 5)
str_view_all(effects_CI$sentence[random_sentences], str_c(
    num_effect, "(?=[^\\d\\.]{0,17}([^\\.\\d]", string_confint, "))(?<!\\b95)|",
      num_effect, "(?=[^\\d\\.]{0,5}(\\(|\\[)", num_confint, "(?=%?[\\)\\];]))(?<![^\\.\\d]95)",
    "|((?<=", string_confint, "[^\\d]{0,4})", num_confint, ")|",
      "(?<=", num_effect, "[^\\d\\.]{0,5})(?<=(\\(|\\[))", num_confint, "(?=%?[\\)\\];])"))
```

Once the effects and CI are identified, some wrangling is necessary in order to get the data into a usable format. We also choose to **drop effects which do not fall into the CI** (62 estimates) in order to get rid off most of the poorly detected effects-CIs. 

```{r}
effects_CI_clean <- effects_CI %>% 
  filter(lengths(effect) == lengths(CI)) %>% #if number of effects != nb of CI for a sentence,
  #can't attribute effects to CI so, drop sentence
  unnest(c(effect, CI), keep_empty = TRUE) %>%
  mutate(CI = str_remove_all(CI, "\\s")) %>% 
  # separate(CI, into = c("low_CI", "up_CI"), "([\\s,]+)|(?<!^)[-–]") %>% 
  separate(CI, into = c("low_CI", "up_CI"), "(?<!^)[–:;,%\\-to\\‐]{1,5}") %>%
  mutate(across(c("effect", "low_CI", "up_CI"), .fns = as.numeric)) %>% 
  mutate(
    low_CI = ifelse(is.na(up_CI), NA, low_CI),
    up_CI = ifelse(is.na(low_CI), NA, up_CI),
    effect = ifelse(is.na(low_CI), NA, effect)
  ) %>% 
  select(-sentence, -abstract, -contains_CI) %>%
  filter(!is.na(effect)) %>%  
  filter(effect > low_CI & effect < up_CI)

articles_effect <- abstracts %>% 
  left_join(effects_CI_clean, by = "doi")

saveRDS(articles_effect, "../Outputs/articles_effect.RDS")
```



```{r}
articles_effect %>%
  mutate(
    contains_CI = str_detect(abstract, "(95%|\\bCI\\b|\\b(c|C)onfidence (i|I)nterval\\b)")
  ) %>%
  filter(contains_CI) %>%
  group_by(doi) %>%
  summarise(has_effect = mean(effect, na.rm = TRUE)) %>%
  count(ret = !is.nan(has_effect)) %>%
  mutate(ret = ifelse(ret, "Yes", "No")) %>%
  kable(col.names = c("Effect retreived", "Number of articles"), caption = "Number of articles for which at least one effect is retrieved (out of those containing the phrase CI)")

no_effect <- effects_CI %>%
  mutate(effect = as.character(effect)) %>%
  filter(effect == "character(0)")

str_view_all(no_effect$sentence, "lom")
```


## Retreiving additional information

It might also be interesting to information about the type of pollutant considered in the study, the study period, the number of observations or p-values and the type of outcome studied (mortality, emergency admissions, stroke, cerebrovascular or cardiovascular diseases). We also use regex to recover these information.

```{r}
month_regex <- "\\b(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|(Nov|Dec)(?:ember)?)"
date_regex <- str_c("(",month_regex, "\\s){0,1}(19|20)\\d{2}")

abstracts_more_info <- abstracts %>% 
  mutate(
    abstract = str_replace_all(abstract, "·", ".")
  ) %>% 
  select(doi, abstract, title) %>%
  mutate(
    dates_obs = str_extract_all(abstract, str_c(date_regex, "( to |\\s?—\\s?|\\s?-\\s?| and )", date_regex))
  ) %>% 
  unnest(dates_obs, keep_empty = TRUE) %>%
  separate(dates_obs, into = c("begin_obs", "end_obs"), "( to |\\s?—\\s?|\\s?-\\s?| and )") %>% 
  mutate(
    p_value = str_extract_all(abstract, "(?<=\\b(p|P|p-value|p value)\\s?)[=<]\\s?[\\d.]+"),
    n_obs = str_extract_all(abstract, "(?<=(\\bn\\s?= ))[\\d,]{1,10}|[\\d,]{1,8}(?=(\\sobservations))"),
    pollutant = str_extract_all(abstract, "(\\bPM\\s?2(\\.|,)5|\\bPM\\s?10|\\bO\\s?3\\b|\\b(o|O)zone\\b|\\b(P|p)articulate\\s(M|m)atter\\b|\\bNO\\s?2|\\b(n|N)itrogen\\s?(d|D)ioxide\\b|\\bNO\\b|\\b(n|N)itrogen\\s?(o|O)xide\\b|\\bNO\\s?(x|X)\\b|\\bSO\\s?2|\\bCO\\b|\\bBC\\b|\\b(A|a)ir\\s(Q|q)uality\\s(I|i)ndex\\b)")
  ) %>% 
  unnest(pollutant, keep_empty = TRUE) %>% 
  group_by(doi) %>% 
  mutate(
    pollutant = tolower(pollutant), 
    pollutant = str_replace_all(pollutant, "\\s", ""),
    pollutant = str_replace_all(pollutant, ",", "\\."),
    pollutant = ifelse(pollutant == "nitrogendioxide", "no2", pollutant),
    pollutant = ifelse(pollutant == "nitrogenoxide", "no", pollutant),
    pollutant = ifelse(pollutant == "ozone", "o3",pollutant)
  ) %>% 
  distinct(pollutant, .keep_all = TRUE) %>% 
  ungroup() %>% 
  nest(pollutant = pollutant) %>% 
  mutate(
    # outcome = str_extract_all(title, "(\\b(M|m)ortality\\b|\\b(D|d)eath\\b|\\b(H|h)ospitalization|\\b(E|e)mergenc|\\b(S|s)troke|\\b(C|c)erebrovascular\\b|\\b(C|c)ardiovascular\\b)")
    outcome = str_extract_all(title, "(\\b(M|m)ortality\\b|\\b(D|d)eath\\b|\\b(H|h)ospitalization|\\b(E|e)mergenc)")
  ) %>% 
  unnest(outcome, keep_empty = TRUE) %>% 
  group_by(doi) %>%
   mutate(
    outcome = tolower(outcome),
    outcome = ifelse(outcome %in% c("emergenc", "hospitalization"), "Emergency",
                     ifelse(outcome %in% c("death", "mortality"), "Mortality", NA))
  ) %>%
  distinct(outcome, .keep_all = TRUE) %>%
  ungroup() %>%
  nest(outcome = outcome) %>%
  select(-title)


saveRDS(abstracts_more_info, "../Outputs/abstracts_more_info.RDS")
```


# Analysis of papers dealing with power and missingness issues

## Retreiving the full texts

We then download the full texts (using the `ft_get` functions). The full texts are stored in an xml format in the cache directory. Note that due to my IP address being located outside of Columbia, I cannot access the texts from Scopus.

```{r eval = FALSE}
#set folder to store downloads
cache_options_set(full_path = "/Users/vincentbagilet/Documents/fulltext")
# cache_options_set(full_path = "/Volumes/VincentSSD/Research_data/air_pollution/lit_review/full_texts")

metadata_lit_review <- readRDS("../Outputs/metadata_lit_review.RDS")
metadata_scopus <- readRDS("../Outputs/metadata_scopus.RDS")

metadata_lit_review$doi %>% 
  ft_get(progress = TRUE)

metadata_scopus$doi[1:10] %>% 
  ft_get(from = "elsevier")

"10.1016/j.scitotenv.2021.145777" 
  
"10.1016/j.envint.2021.106434" %>% 
  ft_get(from = "elsevier")

metadata_entrez$doi %>% 
  ft_get(from = "entrez", progress = TRUE)
```

Links to test directly whether that works

```{r}
https://api.elsevier.com/content/article/doi/10.1016/j.scitotenv.2021.145725?APIKey= 	973798cb29f35f1e72306fda025bc1ad

https://api.elsevier.com/authenticate/X-ELS-APIKey=973798cb29f35f1e72306fda025bc1ad

https://api.elsevier.com/content/article/doi/10.1016/j.envint.2021.106434?APIKey=97cf76b54716b952af1b960bd830356a?view=FULL

https://api.elsevier.com/content/article/doi/10.1016/j.envint.2021.106434

10.1016/j.envint.2021.106434

https://api.elsevier.com/content/article/pii/S0048969721008445?APIKey=ff394d7bf223e93a318f64d387997d42?view=FULL
```


Once we have downloaded all the files, we can put them into a table format, before analyzing them.

```{r eval = FALSE}
metadata_scopus$doi[1:10] %>% 
  ft_get(from = "elsevier")

#put text into a table format
article_texts <- ft_table() %>% #searches for documents in the cache directory 
  select(-paths, -ids_norm) # %>% 
#   .$text 

saveRDS(article_texts, "../Outputs/article_texts.RDS")
```

## Analysis

To analyse the texts, we first start by simply exploring the proportion of articles mentioning the words "missing" and "power".

```{r eval = FALSE}
readRDS("../Outputs/article_texts.RDS")

article_texts %>%
  summarise(
    contains_missing = sum(str_detect(text, pattern = "\\bmissing"))/n(), #could put a vector with various terms
    contains_power = sum(str_detect(text, pattern = "\\bpower\\b"))/n() #statistical power
  )
```

<!-- # Test with rentrez package -->

<!-- ```{r} -->
<!-- querry_entrez <- "((air pollution[TITL]  OR air quality[TITL] OR particulate matter[TITL] OR ozone[TITL] OR nitrogen dioxide[TITL] OR sulfur dioxide[TITL]) AND (emergency[TITL] OR mortality[TITL])) AND (particulate matter[TIAB] OR ozone[TIAB] OR nitrogen dioxide[TIAB] OR sulfur dioxide[TIAB])" -->

<!-- rentrez_search <- entrez_search(db = "pubmed", term = querry_entrez, use_history = TRUE) -->
<!-- rentrez_ids <- rentrez_search$ids %>% as.numeric() -->

<!-- rentrez_texts <- entrez_fetch(db = "pubmed", id = rentrez_ids, rettype = "xml") -->

<!-- t <- rentrez_texts %>% -->
<!--   xmlParse() %>% -->
<!--   xmlToList() -->

<!-- retrieve_abstract <- function(lis) { -->
<!--   df <- lis$MedlineCitation$Article$Abstract %>% -->
<!--   map_df(., data.frame) %>% -->
<!--   as.tibble() %>% -->
<!--   distinct() -->

<!--   # %>% -->
<!--   # filter(!is.na(text)) %>% -->
<!--   # select(-3) -->

<!--   return(df) -->
<!-- } -->

<!-- out <- map_df(t, retrieve_abstract) -->

<!-- r <- t$PubmedArticle$MedlineCitation$Article$Abstract %>% -->
<!--   map_df(., data.frame) %>% -->
<!--   as.tibble() %>% -->
<!--   distinct() %>% -->
<!--   filter(!is.na(text)) %>% -->
<!--   select(-3) -->

<!-- t$PubmedArticle$MedlineCitation$Article -->
<!-- ``` -->




